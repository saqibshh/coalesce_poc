{#
    Copyright (c) 2023 Coalesce. All rights reserved.
This script and its associated documentation are confidential and proprietary to Coalesce.
Unauthorized reproduction, distribution, or disclosure of this material is strictly prohibited.
Coalesce permits you to copy and modify this script for the purposes of using with Coalsce but
does not permit copying or modification for any other purpose.  
#}
{# == Node Type Version        : 1  == #}
{# == Node Type Name           : Flatten Variant to Columns == #}
{# == Node Type Description    : This node flattens VARIANT fields from external tables into proper columns with inferred data types == #}
{#Release date:20250109 Version:1.0.0#}

{# Storage Location-database and schema #}
{% set srcSchName = node.location.name %}
{% set db = storageLocations | selectattr('name', 'equalto', srcSchName) | map(attribute='database') | first %}
{% set sch = storageLocations | selectattr('name', 'equalto', srcSchName) | map(attribute='schema') | first %}

{# Parse source external table #}
{% set sourceTableParts = config.sourceExternalTable.split('.') %}
{% set sourceDb = sourceTableParts[0] %}
{% set sourceSch = sourceTableParts[1] %}
{% set sourceTable = sourceTableParts[2] %}

{# Flatten mode configuration #}
{% set flattenModeSQL = "" %}
{% if config.flattenMode == "OBJECT" %}
    {% set flattenModeSQL = "MODE => 'OBJECT'" %}
{% elif config.flattenMode == "ARRAY" %}
    {% set flattenModeSQL = "MODE => 'ARRAY'" %}
{% elif config.flattenMode == "BOTH" %}
    {% set flattenModeSQL = "MODE => 'BOTH'" %}
{% endif %}

{# Recursive flattening configuration #}
{% set recursiveSQL = "" %}
{% if config.recursiveFlatten %}
    {% set recursiveSQL = "RECURSIVE => TRUE" %}
{% endif %}

{# Build flatten parameters #}
{% set flattenParams = [] %}
{% if flattenModeSQL %}
    {% set flattenParams = flattenParams + [flattenModeSQL] %}
{% endif %}
{% if recursiveSQL %}
    {% set flattenParams = flattenParams + [recursiveSQL] %}
{% endif %}
{% set flattenParamsSQL = flattenParams | join(", ") %}

{# Handle null values configuration #}
{% set nullHandlingSQL = "" %}
{% if config.handleNullValues == "EXCLUDE" %}
    {% set nullHandlingSQL = "WHERE value IS NOT NULL" %}
{% elif config.handleNullValues == "DEFAULT" %}
    {% set nullHandlingSQL = "COALESCE(value, " + config.nullDefaultValue + ")" %}
{% endif %}

{# Column naming function #}
{% macro apply_naming_convention(column_name) %}
    {% if config.columnNaming == "SNAKE_CASE" %}
        {{ column_name | replace('.', '_') | replace('-', '_') | lower }}
    {% elif config.columnNaming == "CAMEL_CASE" %}
        {{ column_name | replace('.', '_') | replace('-', '_') | title | replace('_', '') | lower }}
    {% elif config.columnNaming == "UPPER_CASE" %}
        {{ column_name | replace('.', '_') | replace('-', '_') | upper }}
    {% elif config.columnNaming == "LOWER_CASE" %}
        {{ column_name | replace('.', '_') | replace('-', '_') | lower }}
    {% else %}
        {{ column_name }}
    {% endif %}
{% endmacro %}

{# Apply prefix and suffix #}
{% macro apply_prefix_suffix(column_name) %}
    {% set final_name = column_name %}
    {% if config.columnPrefix %}
        {% set final_name = config.columnPrefix + final_name %}
    {% endif %}
    {% if config.columnSuffix %}
        {% set final_name = final_name + config.columnSuffix %}
    {% endif %}
    {{ final_name }}
{% endmacro %}

{# Schema inference query #}
{% if config.inferDataTypes %}
    {{ stage('Schema Inference') }}
    
    CREATE OR REPLACE TEMPORARY TABLE temp_schema_inference AS
    SELECT 
        key,
        value,
        path,
        index,
        this
    FROM {{ sourceDb }}.{{ sourceSch }}.{{ sourceTable }},
    LATERAL FLATTEN(input => {{ config.variantColumnName }}, path => '{{ config.flattenPath }}'{% if flattenParamsSQL %}, {{ flattenParamsSQL }}{% endif %})
    LIMIT {{ config.sampleSize }};

    {{ stage('Data Type Analysis') }}
    
    CREATE OR REPLACE TEMPORARY TABLE temp_data_types AS
    SELECT 
        key,
        CASE 
            WHEN TRY_CAST(value AS BOOLEAN) IS NOT NULL THEN 'BOOLEAN'
            WHEN TRY_CAST(value AS NUMBER) IS NOT NULL THEN 'NUMBER'
            WHEN TRY_CAST(value AS TIMESTAMP_NTZ) IS NOT NULL THEN 'TIMESTAMP_NTZ'
            WHEN TRY_CAST(value AS DATE) IS NOT NULL THEN 'DATE'
            WHEN TRY_CAST(value AS TIME) IS NOT NULL THEN 'TIME'
            WHEN IS_OBJECT(value) THEN 'OBJECT'
            WHEN IS_ARRAY(value) THEN 'ARRAY'
            ELSE 'STRING'
        END AS inferred_type,
        MAX(LENGTH(TRY_CAST(value AS STRING))) AS max_length
    FROM temp_schema_inference
    WHERE value IS NOT NULL
    GROUP BY key;
{% endif %}

{# Main flattening query #}
{% if config.materializationType == 'view' %}
    {{ stage('Create Flattened View') }}
    
    CREATE OR REPLACE VIEW "{{ db }}"."{{ sch }}"."{{ node.name }}" AS
{% else %}
    {% if config.truncateBefore %}
        {{ stage('Truncate Target Table') }}
        TRUNCATE TABLE IF EXISTS "{{ db }}"."{{ sch }}"."{{ node.name }}"
    {% endif %}
    
    {{ stage('Create Flattened Table') }}
    
    {% if config.materializationType == 'transient table' %}
        CREATE OR REPLACE TRANSIENT TABLE "{{ db }}"."{{ sch }}"."{{ node.name }}" AS
    {% else %}
        CREATE OR REPLACE TABLE "{{ db }}"."{{ sch }}"."{{ node.name }}" AS
    {% endif %}
{% endif %}

WITH flattened_data AS (
    SELECT 
        {% if config.inferDataTypes %}
            {% set ns = namespace(counter=1) %}
            {% for col in sources[0].columns %}
                {% if not( col.sysFlattenTs or col.sysSourceRowId or col.sysFlattenPath or col.sysIndex or col.sysKey or col.sysValue or col.sysThis ) %}
                    {% if col.name == config.variantColumnName %}
                        -- Skip the variant column as we're flattening it
                    {% else %}
                        "{{ col.name }}"
                        {%- if not loop.last -%}, {% endif %}
                    {% endif %}
                {% endif %}
            {% endfor %}
            ,
        {% endif %}
        key,
        value,
        path,
        index,
        this,
        current_timestamp()::timestamp_ntz AS FLATTEN_TIMESTAMP,
        metadata$file_row_number AS SOURCE_ROW_ID
    FROM {{ sourceDb }}.{{ sourceSch }}.{{ sourceTable }},
    LATERAL FLATTEN(input => {{ config.variantColumnName }}, path => '{{ config.flattenPath }}'{% if flattenParamsSQL %}, {{ flattenParamsSQL }}{% endif %})
    {% if config.handleNullValues == "EXCLUDE" %}
        WHERE value IS NOT NULL
    {% endif %}
),
pivoted_data AS (
    SELECT 
        {% if config.inferDataTypes %}
            {% for col in sources[0].columns %}
                {% if not( col.sysFlattenTs or col.sysSourceRowId or col.sysFlattenPath or col.sysIndex or col.sysKey or col.sysValue or col.sysThis ) %}
                    {% if col.name != config.variantColumnName %}
                        "{{ col.name }}",
                    {% endif %}
                {% endif %}
            {% endfor %}
        {% endif %}
        FLATTEN_TIMESTAMP,
        SOURCE_ROW_ID,
        {% if config.inferDataTypes %}
            {% set ns = namespace(counter=1) %}
            {% for row in range(1, 100) %}  {# Assuming max 100 columns #}
                {% set col_name = "col_" + row | string %}
                MAX(CASE WHEN key = '{{ col_name }}' THEN 
                    {% if config.handleNullValues == "DEFAULT" %}
                        COALESCE(value, {{ config.nullDefaultValue }})
                    {% else %}
                        value
                    {% endif %}
                END) AS "{{ apply_prefix_suffix(apply_naming_convention(col_name)) }}"
                {%- if not loop.last -%}, {% endif %}
            {% endfor %}
        {% else %}
            key,
            value,
            path,
            index,
            this
        {% endif %}
    FROM flattened_data
    {% if config.inferDataTypes %}
        GROUP BY 
        {% for col in sources[0].columns %}
            {% if not( col.sysFlattenTs or col.sysSourceRowId or col.sysFlattenPath or col.sysIndex or col.sysKey or col.sysValue or col.sysThis ) %}
                {% if col.name != config.variantColumnName %}
                    "{{ col.name }}",
                {% endif %}
            {% endif %}
        {% endfor %}
        FLATTEN_TIMESTAMP, SOURCE_ROW_ID
    {% endif %}
)
SELECT * FROM pivoted_data
{% if config.batchSize and config.batchSize != "" %}
    LIMIT {{ config.batchSize }}
{% endif %};
