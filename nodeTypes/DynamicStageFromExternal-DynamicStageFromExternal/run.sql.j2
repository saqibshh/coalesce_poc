{#
    Copyright (c) 2023 Coalesce. All rights reserved.
This script and its associated documentation are confidential and proprietary to Coalesce.
Unauthorized reproduction, distribution, or disclosure of this material is strictly prohibited.
Coalesce permits you to copy and modify this script for the purposes of using with Coalsce but
does not permit copying or modification for any other purpose.  
#}
{# == Node Type Version        : 1  == #}
{# == Node Type Name           : Dynamic Stage from External == #}
{# == Node Type Description    : Creates dynamic stage table from external table with schema inference based on filtered date data == #}
{#Release date:20250109 Version:1.0.0#}

{# Storage Location-database and schema #}
{% set srcSchName = node.location.name %}
{% set db = storageLocations | selectattr('name', 'equalto', srcSchName) | map(attribute='database') | first %}
{% set sch = storageLocations | selectattr('name', 'equalto', srcSchName) | map(attribute='schema') | first %}

{# Use upstream source (external table) #}
{% set sourceDb = sources[0].location.database %}
{% set sourceSch = sources[0].location.schema %}
{% set sourceTable = sources[0].name %}

{# Column naming function #}
{% macro apply_naming_convention(column_name) %}
    {% if config.columnNaming == "SNAKE_CASE" %}
        {{ (config.columnPrefix + column_name) | replace('.', '_') | replace('-', '_') | replace(' ', '_') | upper }}
    {% elif config.columnNaming == "CAMEL_CASE" %}
        {{ (config.columnPrefix + column_name) | replace('.', '_') | replace('-', '_') | replace(' ', '_') | title | replace('_', '') }}
    {% elif config.columnNaming == "UPPER_CASE" %}
        {{ (config.columnPrefix + column_name) | replace('.', '_') | replace('-', '_') | replace(' ', '_') | upper }}
    {% elif config.columnNaming == "LOWER_CASE" %}
        {{ (config.columnPrefix + column_name) | replace('.', '_') | replace('-', '_') | replace(' ', '_') | lower }}
    {% else %}
        {{ config.columnPrefix + column_name }}
    {% endif %}
{% endmacro %}

{# Data type inference function #}
{% macro infer_data_type(sample_value) %}
    {% if config.inferDataTypes %}
        CASE 
            WHEN TRY_CAST({{ sample_value }} AS BOOLEAN) IS NOT NULL AND {{ sample_value }}::STRING IN ('true', 'false', 'TRUE', 'FALSE', '1', '0') THEN 'BOOLEAN'
            WHEN TRY_CAST({{ sample_value }} AS NUMBER(38,0)) IS NOT NULL AND {{ sample_value }}::STRING NOT LIKE '%.%' THEN 'NUMBER(38,0)'
            WHEN TRY_CAST({{ sample_value }} AS NUMBER(38,10)) IS NOT NULL THEN 'NUMBER(38,10)'
            WHEN TRY_CAST({{ sample_value }} AS TIMESTAMP_NTZ) IS NOT NULL THEN 'TIMESTAMP_NTZ'
            WHEN TRY_CAST({{ sample_value }} AS DATE) IS NOT NULL THEN 'DATE'
            WHEN TRY_CAST({{ sample_value }} AS TIME) IS NOT NULL THEN 'TIME'
            WHEN IS_OBJECT({{ sample_value }}) THEN 'VARIANT'
            WHEN IS_ARRAY({{ sample_value }}) THEN 'VARIANT'
            ELSE 'STRING'
        END
    {% else %}
        'STRING'
    {% endif %}
{% endmacro %}

{# Step 1: Get the process date from variable table #}
{{ stage('Get Process Date from Variable Table') }}

CREATE OR REPLACE TEMPORARY TABLE temp_process_date AS
SELECT {{ config.variableValueColumn }} AS process_date
FROM {{ config.variableTableName }}
WHERE {{ config.variableNameColumn }} = '{{ config.dateVariableName }}';

{# Step 2: Create date filter pattern #}
{{ stage('Create Date Filter Pattern') }}

CREATE OR REPLACE TEMPORARY TABLE temp_date_filter AS
SELECT 
    process_date,
    REPLACE(REPLACE(REPLACE('{{ config.datePattern }}', 'YYYY', YEAR(process_date::DATE)::STRING), 'MM', LPAD(MONTH(process_date::DATE)::STRING, 2, '0')), 'DD', LPAD(DAY(process_date::DATE)::STRING, 2, '0')) AS date_pattern
FROM temp_process_date;

{# Step 3: Sample data for schema inference #}
{{ stage('Sample Data for Schema Inference') }}

CREATE OR REPLACE TEMPORARY TABLE temp_sample_data AS
SELECT 
    {{ config.variantColumnName }} AS variant_data,
    {{ config.dateFilterColumn }} AS filter_column
FROM {{ sourceDb }}.{{ sourceSch }}.{{ sourceTable }}
CROSS JOIN temp_date_filter
WHERE {{ config.dateFilterColumn }} LIKE date_pattern
LIMIT {{ config.sampleSize }};

{# Step 4: Flatten and analyze schema #}
{{ stage('Flatten and Analyze Schema') }}

CREATE OR REPLACE TEMPORARY TABLE temp_flattened_sample AS
SELECT 
    f.key AS column_name,
    f.value AS column_value,
    f.path AS json_path
FROM temp_sample_data s,
LATERAL FLATTEN(input => s.variant_data, recursive => true) f
WHERE f.value IS NOT NULL;

{# Step 5: Infer data types and create schema #}
{{ stage('Infer Data Types and Create Schema') }}

CREATE OR REPLACE TEMPORARY TABLE temp_schema_definition AS
SELECT 
    column_name,
    {{ infer_data_type('column_value') }} AS inferred_type,
    MAX(LENGTH(column_value::STRING)) AS max_length,
    COUNT(*) AS value_count,
    COUNT(DISTINCT column_value) AS distinct_count
FROM temp_flattened_sample
WHERE json_path NOT LIKE '%[%]%'  -- Exclude array elements for now
GROUP BY column_name
ORDER BY column_name;

{# Step 6: Generate CREATE TABLE statement dynamically #}
{{ stage('Generate Dynamic CREATE TABLE Statement') }}

CREATE OR REPLACE TEMPORARY TABLE temp_create_statement AS
SELECT 
    'CREATE OR REPLACE ' + 
    {% if config.materializationType == 'transient table' %}
        'TRANSIENT TABLE '
    {% else %}
        'TABLE '
    {% endif %} +
    '"{{ db }}"."{{ sch }}"."{{ node.name }}" (' +
    LISTAGG(
        '"' + {{ apply_naming_convention('column_name') }} + '" ' + 
        CASE 
            WHEN inferred_type = 'STRING' THEN 'STRING(' + GREATEST(max_length, {{ config.defaultStringLength }})::STRING + ')'
            ELSE inferred_type 
        END, 
        ', '
    ) WITHIN GROUP (ORDER BY column_name) +
    {% if columns | selectattr('sysLoadTs') | list | length > 0 or 
          columns | selectattr('sysSourceFilename') | list | length > 0 or 
          columns | selectattr('sysSourceRowNumber') | list | length > 0 or 
          columns | selectattr('sysProcessDate') | list | length > 0 %}
        ', ' +
        {% set system_cols = [] %}
        {% for col in columns %}
            {% if col.sysLoadTs %}
                {% set system_cols = system_cols + ['"LOAD_TIMESTAMP" TIMESTAMP_NTZ'] %}
            {% elif col.sysSourceFilename %}
                {% set system_cols = system_cols + ['"SOURCE_FILENAME" STRING'] %}
            {% elif col.sysSourceRowNumber %}
                {% set system_cols = system_cols + ['"SOURCE_ROW_NUMBER" NUMBER'] %}
            {% elif col.sysProcessDate %}
                {% set system_cols = system_cols + ['"PROCESS_DATE" DATE'] %}
            {% endif %}
        {% endfor %}
        '{{ system_cols | join(", ") }}'
    {% endif %} +
    ')' AS create_statement
FROM temp_schema_definition;

{# Step 7: Execute dynamic CREATE TABLE #}
{{ stage('Execute Dynamic CREATE TABLE') }}

{% if config.truncateBefore %}
    DROP TABLE IF EXISTS "{{ db }}"."{{ sch }}"."{{ node.name }}";
{% endif %}

EXECUTE IMMEDIATE (SELECT create_statement FROM temp_create_statement);

{# Step 8: Generate and execute dynamic INSERT statement #}
{{ stage('Generate and Execute Dynamic INSERT') }}

CREATE OR REPLACE TEMPORARY TABLE temp_insert_statement AS
SELECT 
    'INSERT INTO "{{ db }}"."{{ sch }}"."{{ node.name }}" (' +
    LISTAGG('"' + {{ apply_naming_convention('column_name') }}, ', ') WITHIN GROUP (ORDER BY column_name) +
    {% if columns | selectattr('sysLoadTs') | list | length > 0 or 
          columns | selectattr('sysSourceFilename') | list | length > 0 or 
          columns | selectattr('sysSourceRowNumber') | list | length > 0 or 
          columns | selectattr('sysProcessDate') | list | length > 0 %}
        ', ' +
        {% set system_col_names = [] %}
        {% for col in columns %}
            {% if col.sysLoadTs %}
                {% set system_col_names = system_col_names + ['"LOAD_TIMESTAMP"'] %}
            {% elif col.sysSourceFilename %}
                {% set system_col_names = system_col_names + ['"SOURCE_FILENAME"'] %}
            {% elif col.sysSourceRowNumber %}
                {% set system_col_names = system_col_names + ['"SOURCE_ROW_NUMBER"'] %}
            {% elif col.sysProcessDate %}
                {% set system_col_names = system_col_names + ['"PROCESS_DATE"'] %}
            {% endif %}
        {% endfor %}
        '{{ system_col_names | join(", ") }}'
    {% endif %} +
    ') SELECT ' +
    LISTAGG(
        {% if config.handleNestedObjects == "FLATTEN" %}
            'f.value::' + 
            CASE 
                WHEN inferred_type = 'STRING' THEN 'STRING(' + GREATEST(max_length, {{ config.defaultStringLength }})::STRING + ')'
                ELSE inferred_type 
            END + ' AS "' + {{ apply_naming_convention('column_name') }} + '"'
        {% elif config.handleNestedObjects == "JSON_STRING" %}
            'f.value::STRING AS "' + {{ apply_naming_convention('column_name') }} + '"'
        {% else %}
            'f.value AS "' + {{ apply_naming_convention('column_name') }} + '"'
        {% endif %},
        ', '
    ) WITHIN GROUP (ORDER BY column_name) +
    {% if columns | selectattr('sysLoadTs') | list | length > 0 or 
          columns | selectattr('sysSourceFilename') | list | length > 0 or 
          columns | selectattr('sysSourceRowNumber') | list | length > 0 or 
          columns | selectattr('sysProcessDate') | list | length > 0 %}
        ', ' +
        {% set system_col_values = [] %}
        {% for col in columns %}
            {% if col.sysLoadTs %}
                {% set system_col_values = system_col_values + ['current_timestamp()::timestamp_ntz'] %}
            {% elif col.sysSourceFilename %}
                {% set system_col_values = system_col_values + ['src.{{ config.dateFilterColumn }}'] %}
            {% elif col.sysSourceRowNumber %}
                {% set system_col_values = system_col_values + ['METADATA$FILE_ROW_NUMBER'] %}
            {% elif col.sysProcessDate %}
                {% set system_col_values = system_col_values + ['df.process_date::DATE'] %}
            {% endif %}
        {% endfor %}
        '{{ system_col_values | join(", ") }}'
    {% endif %} +
    ' FROM {{ sourceDb }}.{{ sourceSch }}.{{ sourceTable }} src ' +
    'CROSS JOIN temp_date_filter df, ' +
    'LATERAL FLATTEN(input => src.{{ config.variantColumnName }}, recursive => true) f ' +
    'WHERE src.{{ config.dateFilterColumn }} LIKE df.date_pattern ' +
    'AND f.key IN (' + LISTAGG('''' + column_name + '''', ', ') WITHIN GROUP (ORDER BY column_name) + ')' +
    {% if config.batchSize and config.batchSize != "" %}
        ' LIMIT {{ config.batchSize }}'
    {% endif %} AS insert_statement
FROM temp_schema_definition;

{{ stage('Execute Dynamic INSERT') }}

EXECUTE IMMEDIATE (SELECT insert_statement FROM temp_insert_statement);

{# Step 9: Create indexes if requested #}
{% if config.createIndexes %}
    {{ stage('Create Indexes on Date/Timestamp Columns') }}
    
    CREATE OR REPLACE TEMPORARY TABLE temp_index_statements AS
    SELECT 
        'CREATE INDEX IF NOT EXISTS idx_' + {{ apply_naming_convention('column_name') }} + 
        ' ON "{{ db }}"."{{ sch }}"."{{ node.name }}" ("' + {{ apply_naming_convention('column_name') }} + '")' AS index_statement
    FROM temp_schema_definition
    WHERE inferred_type IN ('DATE', 'TIMESTAMP_NTZ', 'TIMESTAMP_LTZ', 'TIMESTAMP_TZ');
    
    -- Note: Execute these index statements individually if needed
    -- Snowflake may not support all index types
{% endif %}

{# Step 10: Cleanup temporary tables #}
{{ stage('Cleanup Temporary Tables') }}

DROP TABLE IF EXISTS temp_process_date;
DROP TABLE IF EXISTS temp_date_filter;
DROP TABLE IF EXISTS temp_sample_data;
DROP TABLE IF EXISTS temp_flattened_sample;
DROP TABLE IF EXISTS temp_schema_definition;
DROP TABLE IF EXISTS temp_create_statement;
DROP TABLE IF EXISTS temp_insert_statement;
{% if config.createIndexes %}
DROP TABLE IF EXISTS temp_index_statements;
{% endif %}
